{
  "version": 3,
  "sources": ["../../preact/hooks/src/index.js", "../../preact-router/src/util.js", "../../preact-router/src/index.js"],
  "sourcesContent": ["import { options as _options } from 'preact';\n\n/** @type {number} */\nlet currentIndex;\n\n/** @type {import('./internal').Component} */\nlet currentComponent;\n\n/** @type {import('./internal').Component} */\nlet previousComponent;\n\n/** @type {number} */\nlet currentHook = 0;\n\n/** @type {Array<import('./internal').Component>} */\nlet afterPaintEffects = [];\n\n// Cast to use internal Options type\nconst options = /** @type {import('./internal').Options} */ (_options);\n\nlet oldBeforeDiff = options._diff;\nlet oldBeforeRender = options._render;\nlet oldAfterDiff = options.diffed;\nlet oldCommit = options._commit;\nlet oldBeforeUnmount = options.unmount;\nlet oldRoot = options._root;\n\n// We take the minimum timeout for requestAnimationFrame to ensure that\n// the callback is invoked after the next frame. 35ms is based on a 30hz\n// refresh rate, which is the minimum rate for a smooth user experience.\nconst RAF_TIMEOUT = 35;\nlet prevRaf;\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions._diff = vnode => {\n\tcurrentComponent = null;\n\tif (oldBeforeDiff) oldBeforeDiff(vnode);\n};\n\noptions._root = (vnode, parentDom) => {\n\tif (vnode && parentDom._children && parentDom._children._mask) {\n\t\tvnode._mask = parentDom._children._mask;\n\t}\n\n\tif (oldRoot) oldRoot(vnode, parentDom);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions._render = vnode => {\n\tif (oldBeforeRender) oldBeforeRender(vnode);\n\n\tcurrentComponent = vnode._component;\n\tcurrentIndex = 0;\n\n\tconst hooks = currentComponent.__hooks;\n\tif (hooks) {\n\t\tif (previousComponent === currentComponent) {\n\t\t\thooks._pendingEffects = [];\n\t\t\tcurrentComponent._renderCallbacks = [];\n\t\t\thooks._list.forEach(hookItem => {\n\t\t\t\tif (hookItem._nextValue) {\n\t\t\t\t\thookItem._value = hookItem._nextValue;\n\t\t\t\t}\n\t\t\t\thookItem._pendingArgs = hookItem._nextValue = undefined;\n\t\t\t});\n\t\t} else {\n\t\t\thooks._pendingEffects.forEach(invokeCleanup);\n\t\t\thooks._pendingEffects.forEach(invokeEffect);\n\t\t\thooks._pendingEffects = [];\n\t\t\tcurrentIndex = 0;\n\t\t}\n\t}\n\tpreviousComponent = currentComponent;\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.diffed = vnode => {\n\tif (oldAfterDiff) oldAfterDiff(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\tif (c.__hooks._pendingEffects.length) afterPaint(afterPaintEffects.push(c));\n\t\tc.__hooks._list.forEach(hookItem => {\n\t\t\tif (hookItem._pendingArgs) {\n\t\t\t\thookItem._args = hookItem._pendingArgs;\n\t\t\t}\n\t\t\thookItem._pendingArgs = undefined;\n\t\t});\n\t}\n\tpreviousComponent = currentComponent = null;\n};\n\n// TODO: Improve typing of commitQueue parameter\n/** @type {(vnode: import('./internal').VNode, commitQueue: any) => void} */\noptions._commit = (vnode, commitQueue) => {\n\tcommitQueue.some(component => {\n\t\ttry {\n\t\t\tcomponent._renderCallbacks.forEach(invokeCleanup);\n\t\t\tcomponent._renderCallbacks = component._renderCallbacks.filter(cb =>\n\t\t\t\tcb._value ? invokeEffect(cb) : true\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tcommitQueue.some(c => {\n\t\t\t\tif (c._renderCallbacks) c._renderCallbacks = [];\n\t\t\t});\n\t\t\tcommitQueue = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t});\n\n\tif (oldCommit) oldCommit(vnode, commitQueue);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.unmount = vnode => {\n\tif (oldBeforeUnmount) oldBeforeUnmount(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\tlet hasErrored;\n\t\tc.__hooks._list.forEach(s => {\n\t\t\ttry {\n\t\t\t\tinvokeCleanup(s);\n\t\t\t} catch (e) {\n\t\t\t\thasErrored = e;\n\t\t\t}\n\t\t});\n\t\tc.__hooks = undefined;\n\t\tif (hasErrored) options._catchError(hasErrored, c._vnode);\n\t}\n};\n\n/**\n * Get a hook's state from the currentComponent\n * @param {number} index The index of the hook to get\n * @param {number} type The index of the hook to get\n * @returns {any}\n */\nfunction getHookState(index, type) {\n\tif (options._hook) {\n\t\toptions._hook(currentComponent, index, currentHook || type);\n\t}\n\tcurrentHook = 0;\n\n\t// Largely inspired by:\n\t// * https://github.com/michael-klein/funcy.js/blob/f6be73468e6ec46b0ff5aa3cc4c9baf72a29025a/src/hooks/core_hooks.mjs\n\t// * https://github.com/michael-klein/funcy.js/blob/650beaa58c43c33a74820a3c98b3c7079cf2e333/src/renderer.mjs\n\t// Other implementations to look at:\n\t// * https://codesandbox.io/s/mnox05qp8\n\tconst hooks =\n\t\tcurrentComponent.__hooks ||\n\t\t(currentComponent.__hooks = {\n\t\t\t_list: [],\n\t\t\t_pendingEffects: []\n\t\t});\n\n\tif (index >= hooks._list.length) {\n\t\thooks._list.push({});\n\t}\n\n\treturn hooks._list[index];\n}\n\n/**\n * @template {unknown} S\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} [initialState]\n * @returns {[S, (state: S) => void]}\n */\nexport function useState(initialState) {\n\tcurrentHook = 1;\n\treturn useReducer(invokeOrReturn, initialState);\n}\n\n/**\n * @template {unknown} S\n * @template {unknown} A\n * @param {import('./index').Reducer<S, A>} reducer\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} initialState\n * @param {(initialState: any) => void} [init]\n * @returns {[ S, (state: S) => void ]}\n */\nexport function useReducer(reducer, initialState, init) {\n\t/** @type {import('./internal').ReducerHookState} */\n\tconst hookState = getHookState(currentIndex++, 2);\n\thookState._reducer = reducer;\n\tif (!hookState._component) {\n\t\thookState._value = [\n\t\t\t!init ? invokeOrReturn(undefined, initialState) : init(initialState),\n\n\t\t\taction => {\n\t\t\t\tconst currentValue = hookState._nextValue\n\t\t\t\t\t? hookState._nextValue[0]\n\t\t\t\t\t: hookState._value[0];\n\t\t\t\tconst nextValue = hookState._reducer(currentValue, action);\n\n\t\t\t\tif (currentValue !== nextValue) {\n\t\t\t\t\thookState._nextValue = [nextValue, hookState._value[1]];\n\t\t\t\t\thookState._component.setState({});\n\t\t\t\t}\n\t\t\t}\n\t\t];\n\n\t\thookState._component = currentComponent;\n\n\t\tif (!currentComponent._hasScuFromHooks) {\n\t\t\tcurrentComponent._hasScuFromHooks = true;\n\t\t\tlet prevScu = currentComponent.shouldComponentUpdate;\n\t\t\tconst prevCWU = currentComponent.componentWillUpdate;\n\n\t\t\t// If we're dealing with a forced update `shouldComponentUpdate` will\n\t\t\t// not be called. But we use that to update the hook values, so we\n\t\t\t// need to call it.\n\t\t\tcurrentComponent.componentWillUpdate = function (p, s, c) {\n\t\t\t\tif (this._force) {\n\t\t\t\t\tlet tmp = prevScu;\n\t\t\t\t\t// Clear to avoid other sCU hooks from being called\n\t\t\t\t\tprevScu = undefined;\n\t\t\t\t\tupdateHookState(p, s, c);\n\t\t\t\t\tprevScu = tmp;\n\t\t\t\t}\n\n\t\t\t\tif (prevCWU) prevCWU.call(this, p, s, c);\n\t\t\t};\n\n\t\t\t// This SCU has the purpose of bailing out after repeated updates\n\t\t\t// to stateful hooks.\n\t\t\t// we store the next value in _nextValue[0] and keep doing that for all\n\t\t\t// state setters, if we have next states and\n\t\t\t// all next states within a component end up being equal to their original state\n\t\t\t// we are safe to bail out for this specific component.\n\t\t\t/**\n\t\t\t *\n\t\t\t * @type {import('./internal').Component[\"shouldComponentUpdate\"]}\n\t\t\t */\n\t\t\t// @ts-ignore - We don't use TS to downtranspile\n\t\t\t// eslint-disable-next-line no-inner-declarations\n\t\t\tfunction updateHookState(p, s, c) {\n\t\t\t\tif (!hookState._component.__hooks) return true;\n\n\t\t\t\t/** @type {(x: import('./internal').HookState) => x is import('./internal').ReducerHookState} */\n\t\t\t\tconst isStateHook = x => !!x._component;\n\t\t\t\tconst stateHooks =\n\t\t\t\t\thookState._component.__hooks._list.filter(isStateHook);\n\n\t\t\t\tconst allHooksEmpty = stateHooks.every(x => !x._nextValue);\n\t\t\t\t// When we have no updated hooks in the component we invoke the previous SCU or\n\t\t\t\t// traverse the VDOM tree further.\n\t\t\t\tif (allHooksEmpty) {\n\t\t\t\t\treturn prevScu ? prevScu.call(this, p, s, c) : true;\n\t\t\t\t}\n\n\t\t\t\t// We check whether we have components with a nextValue set that\n\t\t\t\t// have values that aren't equal to one another this pushes\n\t\t\t\t// us to update further down the tree\n\t\t\t\tlet shouldUpdate = hookState._component.props !== p;\n\t\t\t\tstateHooks.forEach(hookItem => {\n\t\t\t\t\tif (hookItem._nextValue) {\n\t\t\t\t\t\tconst currentValue = hookItem._value[0];\n\t\t\t\t\t\thookItem._value = hookItem._nextValue;\n\t\t\t\t\t\thookItem._nextValue = undefined;\n\t\t\t\t\t\tif (currentValue !== hookItem._value[0]) shouldUpdate = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn prevScu\n\t\t\t\t\t? prevScu.call(this, p, s, c) || shouldUpdate\n\t\t\t\t\t: shouldUpdate;\n\t\t\t}\n\n\t\t\tcurrentComponent.shouldComponentUpdate = updateHookState;\n\t\t}\n\t}\n\n\treturn hookState._nextValue || hookState._value;\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 3);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentComponent.__hooks._pendingEffects.push(state);\n\t}\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useLayoutEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 4);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentComponent._renderCallbacks.push(state);\n\t}\n}\n\n/** @type {(initialValue: unknown) => unknown} */\nexport function useRef(initialValue) {\n\tcurrentHook = 5;\n\treturn useMemo(() => ({ current: initialValue }), []);\n}\n\n/**\n * @param {object} ref\n * @param {() => object} createHandle\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useImperativeHandle(ref, createHandle, args) {\n\tcurrentHook = 6;\n\tuseLayoutEffect(\n\t\t() => {\n\t\t\tif (typeof ref == 'function') {\n\t\t\t\tconst result = ref(createHandle());\n\t\t\t\treturn () => {\n\t\t\t\t\tref(null);\n\t\t\t\t\tif (result && typeof result == 'function') result();\n\t\t\t\t};\n\t\t\t} else if (ref) {\n\t\t\t\tref.current = createHandle();\n\t\t\t\treturn () => (ref.current = null);\n\t\t\t}\n\t\t},\n\t\targs == null ? args : args.concat(ref)\n\t);\n}\n\n/**\n * @template {unknown} T\n * @param {() => T} factory\n * @param {unknown[]} args\n * @returns {T}\n */\nexport function useMemo(factory, args) {\n\t/** @type {import('./internal').MemoHookState<T>} */\n\tconst state = getHookState(currentIndex++, 7);\n\tif (argsChanged(state._args, args)) {\n\t\tstate._value = factory();\n\t\tstate._args = args;\n\t\tstate._factory = factory;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * @param {() => void} callback\n * @param {unknown[]} args\n * @returns {() => void}\n */\nexport function useCallback(callback, args) {\n\tcurrentHook = 8;\n\treturn useMemo(() => callback, args);\n}\n\n/**\n * @param {import('./internal').PreactContext} context\n */\nexport function useContext(context) {\n\tconst provider = currentComponent.context[context._id];\n\t// We could skip this call here, but than we'd not call\n\t// `options._hook`. We need to do that in order to make\n\t// the devtools aware of this hook.\n\t/** @type {import('./internal').ContextHookState} */\n\tconst state = getHookState(currentIndex++, 9);\n\t// The devtools needs access to the context object to\n\t// be able to pull of the default value when no provider\n\t// is present in the tree.\n\tstate._context = context;\n\tif (!provider) return context._defaultValue;\n\t// This is probably not safe to convert to \"!\"\n\tif (state._value == null) {\n\t\tstate._value = true;\n\t\tprovider.sub(currentComponent);\n\t}\n\treturn provider.props.value;\n}\n\n/**\n * Display a custom label for a custom hook for the devtools panel\n * @type {<T>(value: T, cb?: (value: T) => string | number) => void}\n */\nexport function useDebugValue(value, formatter) {\n\tif (options.useDebugValue) {\n\t\toptions.useDebugValue(\n\t\t\tformatter ? formatter(value) : /** @type {any}*/ (value)\n\t\t);\n\t}\n}\n\n/**\n * @param {(error: unknown, errorInfo: import('preact').ErrorInfo) => void} cb\n * @returns {[unknown, () => void]}\n */\nexport function useErrorBoundary(cb) {\n\t/** @type {import('./internal').ErrorBoundaryHookState} */\n\tconst state = getHookState(currentIndex++, 10);\n\tconst errState = useState();\n\tstate._value = cb;\n\tif (!currentComponent.componentDidCatch) {\n\t\tcurrentComponent.componentDidCatch = (err, errorInfo) => {\n\t\t\tif (state._value) state._value(err, errorInfo);\n\t\t\terrState[1](err);\n\t\t};\n\t}\n\treturn [\n\t\terrState[0],\n\t\t() => {\n\t\t\terrState[1](undefined);\n\t\t}\n\t];\n}\n\n/** @type {() => string} */\nexport function useId() {\n\t/** @type {import('./internal').IdHookState} */\n\tconst state = getHookState(currentIndex++, 11);\n\tif (!state._value) {\n\t\t// Grab either the root node or the nearest async boundary node.\n\t\t/** @type {import('./internal').VNode} */\n\t\tlet root = currentComponent._vnode;\n\t\twhile (root !== null && !root._mask && root._parent !== null) {\n\t\t\troot = root._parent;\n\t\t}\n\n\t\tlet mask = root._mask || (root._mask = [0, 0]);\n\t\tstate._value = 'P' + mask[0] + '-' + mask[1]++;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * After paint effects consumer.\n */\nfunction flushAfterPaintEffects() {\n\tlet component;\n\twhile ((component = afterPaintEffects.shift())) {\n\t\tif (!component._parentDom || !component.__hooks) continue;\n\t\ttry {\n\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeCleanup);\n\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeEffect);\n\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t} catch (e) {\n\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t}\n}\n\nlet HAS_RAF = typeof requestAnimationFrame == 'function';\n\n/**\n * Schedule a callback to be invoked after the browser has a chance to paint a new frame.\n * Do this by combining requestAnimationFrame (rAF) + setTimeout to invoke a callback after\n * the next browser frame.\n *\n * Also, schedule a timeout in parallel to the the rAF to ensure the callback is invoked\n * even if RAF doesn't fire (for example if the browser tab is not visible)\n *\n * @param {() => void} callback\n */\nfunction afterNextFrame(callback) {\n\tconst done = () => {\n\t\tclearTimeout(timeout);\n\t\tif (HAS_RAF) cancelAnimationFrame(raf);\n\t\tsetTimeout(callback);\n\t};\n\tconst timeout = setTimeout(done, RAF_TIMEOUT);\n\n\tlet raf;\n\tif (HAS_RAF) {\n\t\traf = requestAnimationFrame(done);\n\t}\n}\n\n// Note: if someone used options.debounceRendering = requestAnimationFrame,\n// then effects will ALWAYS run on the NEXT frame instead of the current one, incurring a ~16ms delay.\n// Perhaps this is not such a big deal.\n/**\n * Schedule afterPaintEffects flush after the browser paints\n * @param {number} newQueueLength\n * @returns {void}\n */\nfunction afterPaint(newQueueLength) {\n\tif (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) {\n\t\tprevRaf = options.requestAnimationFrame;\n\t\t(prevRaf || afterNextFrame)(flushAfterPaintEffects);\n\t}\n}\n\n/**\n * @param {import('./internal').HookState} hook\n * @returns {void}\n */\nfunction invokeCleanup(hook) {\n\t// A hook cleanup can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\tlet cleanup = hook._cleanup;\n\tif (typeof cleanup == 'function') {\n\t\thook._cleanup = undefined;\n\t\tcleanup();\n\t}\n\n\tcurrentComponent = comp;\n}\n\n/**\n * Invoke a Hook's effect\n * @param {import('./internal').EffectHookState} hook\n * @returns {void}\n */\nfunction invokeEffect(hook) {\n\t// A hook call can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\thook._cleanup = hook._value();\n\tcurrentComponent = comp;\n}\n\n/**\n * @param {unknown[]} oldArgs\n * @param {unknown[]} newArgs\n * @returns {boolean}\n */\nfunction argsChanged(oldArgs, newArgs) {\n\treturn (\n\t\t!oldArgs ||\n\t\toldArgs.length !== newArgs.length ||\n\t\tnewArgs.some((arg, index) => arg !== oldArgs[index])\n\t);\n}\n\n/**\n * @template Arg\n * @param {Arg} arg\n * @param {(arg: Arg) => any} f\n * @returns {any}\n */\nfunction invokeOrReturn(arg, f) {\n\treturn typeof f == 'function' ? f(arg) : f;\n}\n", "const EMPTY = {};\n\nexport function assign(obj, props) {\n\t// eslint-disable-next-line guard-for-in\n\tfor (let i in props) {\n\t\tobj[i] = props[i];\n\t}\n\treturn obj;\n}\n\nexport function exec(url, route, opts) {\n\tlet reg = /(?:\\?([^#]*))?(#.*)?$/,\n\t\tc = url.match(reg),\n\t\tmatches = {},\n\t\tret;\n\tif (c && c[1]) {\n\t\tlet p = c[1].split('&');\n\t\tfor (let i = 0; i < p.length; i++) {\n\t\t\tlet r = p[i].split('=');\n\t\t\tmatches[decodeURIComponent(r[0])] = decodeURIComponent(\n\t\t\t\tr.slice(1).join('=')\n\t\t\t);\n\t\t}\n\t}\n\turl = segmentize(url.replace(reg, ''));\n\troute = segmentize(route || '');\n\tlet max = Math.max(url.length, route.length);\n\tfor (let i = 0; i < max; i++) {\n\t\tif (route[i] && route[i].charAt(0) === ':') {\n\t\t\tlet param = route[i].replace(/(^:|[+*?]+$)/g, ''),\n\t\t\t\tflags = (route[i].match(/[+*?]+$/) || EMPTY)[0] || '',\n\t\t\t\tplus = ~flags.indexOf('+'),\n\t\t\t\tstar = ~flags.indexOf('*'),\n\t\t\t\tval = url[i] || '';\n\t\t\tif (!val && !star && (flags.indexOf('?') < 0 || plus)) {\n\t\t\t\tret = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatches[param] = decodeURIComponent(val);\n\t\t\tif (plus || star) {\n\t\t\t\tmatches[param] = url.slice(i).map(decodeURIComponent).join('/');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (route[i] !== url[i]) {\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (opts.default !== true && ret === false) return false;\n\treturn matches;\n}\n\nexport function pathRankSort(a, b) {\n\treturn a.rank < b.rank ? 1 : a.rank > b.rank ? -1 : a.index - b.index;\n}\n\n// filter out VNodes without attributes (which are unrankeable), and add `index`/`rank` properties to be used in sorting.\nexport function prepareVNodeForRanking(vnode, index) {\n\tvnode.index = index;\n\tvnode.rank = rankChild(vnode);\n\treturn vnode.props;\n}\n\nexport function segmentize(url) {\n\treturn url.replace(/(^\\/+|\\/+$)/g, '').split('/');\n}\n\nexport function rankSegment(segment) {\n\treturn segment.charAt(0) == ':'\n\t\t? 1 + '*+?'.indexOf(segment.charAt(segment.length - 1)) || 4\n\t\t: 5;\n}\n\nexport function rank(path) {\n\treturn segmentize(path).map(rankSegment).join('');\n}\n\nfunction rankChild(vnode) {\n\treturn vnode.props.default ? 0 : rank(vnode.props.path);\n}\n", "import {\n\th,\n\tcloneElement,\n\tComponent,\n\ttoChildArray,\n\tcreateContext\n} from 'preact';\nimport { useContext, useState, useEffect } from 'preact/hooks';\nimport { exec, prepareVNodeForRanking, assign, pathRankSort } from './util';\n\nconst EMPTY = {};\nconst ROUTERS = [];\nconst SUBS = [];\nlet customHistory = null;\n\nconst GLOBAL_ROUTE_CONTEXT = {\n\turl: getCurrentUrl()\n};\n\nconst RouterContext = createContext(GLOBAL_ROUTE_CONTEXT);\n\nfunction useRouter() {\n\tconst ctx = useContext(RouterContext);\n\t// Note: this condition can't change without a remount, so it's a safe conditional hook call\n\tif (ctx === GLOBAL_ROUTE_CONTEXT) {\n\t\t// eslint-disable-next-line react-hooks/rules-of-hooks\n\t\tconst update = useState()[1];\n\t\t// eslint-disable-next-line react-hooks/rules-of-hooks\n\t\tuseEffect(() => {\n\t\t\tSUBS.push(update);\n\t\t\treturn () => SUBS.splice(SUBS.indexOf(update), 1);\n\t\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t\t}, []);\n\t}\n\treturn [ctx, route];\n}\n\nfunction setUrl(url, type = 'push') {\n\tif (customHistory && customHistory[type]) {\n\t\tcustomHistory[type](url);\n\t} else if (typeof history !== 'undefined' && history[`${type}State`]) {\n\t\thistory[`${type}State`](null, null, url);\n\t}\n}\n\nfunction getCurrentUrl() {\n\tlet url;\n\tif (customHistory && customHistory.location) {\n\t\turl = customHistory.location;\n\t} else if (customHistory && customHistory.getCurrentLocation) {\n\t\turl = customHistory.getCurrentLocation();\n\t} else {\n\t\turl = typeof location !== 'undefined' ? location : EMPTY;\n\t}\n\treturn `${url.pathname || ''}${url.search || ''}`;\n}\n\nfunction route(url, replace = false) {\n\tif (typeof url !== 'string' && url.url) {\n\t\treplace = url.replace;\n\t\turl = url.url;\n\t}\n\n\t// only push URL into history if we can handle it\n\tif (canRoute(url)) {\n\t\tsetUrl(url, replace ? 'replace' : 'push');\n\t}\n\n\treturn routeTo(url);\n}\n\n/** Check if the given URL can be handled by any router instances. */\nfunction canRoute(url) {\n\tfor (let i = ROUTERS.length; i--; ) {\n\t\tif (ROUTERS[i].canRoute(url)) return true;\n\t}\n\treturn false;\n}\n\n/** Tell all router instances to handle the given URL.  */\nfunction routeTo(url) {\n\tlet didRoute = false;\n\tfor (let i = 0; i < ROUTERS.length; i++) {\n\t\tif (ROUTERS[i].routeTo(url)) {\n\t\t\tdidRoute = true;\n\t\t}\n\t}\n\treturn didRoute;\n}\n\nfunction routeFromLink(node) {\n\t// only valid elements\n\tif (!node || !node.getAttribute) return;\n\n\tlet href = node.getAttribute('href'),\n\t\ttarget = node.getAttribute('target');\n\n\t// ignore links with targets and non-path URLs\n\tif (!href || !href.match(/^\\//g) || (target && !target.match(/^_?self$/i)))\n\t\treturn;\n\n\t// attempt to route, if no match simply cede control to browser\n\treturn route(href);\n}\n\nfunction prevent(e) {\n\tif (e.stopImmediatePropagation) e.stopImmediatePropagation();\n\tif (e.stopPropagation) e.stopPropagation();\n\te.preventDefault();\n\treturn false;\n}\n\n// Handles both delegated and direct-bound link clicks\nfunction delegateLinkHandler(e) {\n\t// ignore events the browser takes care of already:\n\tif (e.ctrlKey || e.metaKey || e.altKey || e.shiftKey || e.button) return;\n\n\tlet t = e.target;\n\tdo {\n\t\tif (t.localName === 'a' && t.getAttribute('href')) {\n\t\t\tif (t.hasAttribute('data-native') || t.hasAttribute('native')) return;\n\t\t\t// if link is handled by the router, prevent browser defaults\n\t\t\tif (routeFromLink(t)) {\n\t\t\t\treturn prevent(e);\n\t\t\t}\n\t\t}\n\t} while ((t = t.parentNode));\n}\n\nlet eventListenersInitialized = false;\n\nfunction initEventListeners() {\n\tif (eventListenersInitialized) return;\n\teventListenersInitialized = true;\n\n\tif (!customHistory) {\n\t\taddEventListener('popstate', () => {\n\t\t\trouteTo(getCurrentUrl());\n\t\t});\n\t}\n\taddEventListener('click', delegateLinkHandler);\n}\n\n/**\n * @class\n * @this {import('preact').Component}\n */\nfunction Router(props) {\n\tif (props.history) {\n\t\tcustomHistory = props.history;\n\t}\n\n\tthis.state = {\n\t\turl: props.url || getCurrentUrl()\n\t};\n}\n\n// @ts-ignore-next-line\nconst RouterProto = (Router.prototype = new Component());\n\nassign(RouterProto, {\n\tshouldComponentUpdate(props) {\n\t\tif (props.static !== true) return true;\n\t\treturn (\n\t\t\tprops.url !== this.props.url || props.onChange !== this.props.onChange\n\t\t);\n\t},\n\n\t/** Check if the given URL can be matched against any children */\n\tcanRoute(url) {\n\t\tconst children = toChildArray(this.props.children);\n\t\treturn this._getMatchingChild(children, url) !== undefined;\n\t},\n\n\t/** Re-render children with a new URL to match against. */\n\trouteTo(url) {\n\t\tthis.setState({ url });\n\n\t\tconst didRoute = this.canRoute(url);\n\n\t\t// trigger a manual re-route if we're not in the middle of an update:\n\t\tif (!this._updating) this.forceUpdate();\n\n\t\treturn didRoute;\n\t},\n\n\tcomponentWillMount() {\n\t\tthis._updating = true;\n\t},\n\n\tcomponentDidMount() {\n\t\tinitEventListeners();\n\t\tROUTERS.push(this);\n\t\tif (customHistory) {\n\t\t\tthis._unlisten = customHistory.listen(action => {\n\t\t\t\tlet location = action.location || action;\n\t\t\t\tthis.routeTo(`${location.pathname || ''}${location.search || ''}`);\n\t\t\t});\n\t\t}\n\t\tthis._updating = false;\n\t},\n\n\tcomponentWillUnmount() {\n\t\tif (typeof this._unlisten === 'function') this._unlisten();\n\t\tROUTERS.splice(ROUTERS.indexOf(this), 1);\n\t},\n\n\tcomponentWillUpdate() {\n\t\tthis._updating = true;\n\t},\n\n\tcomponentDidUpdate() {\n\t\tthis._updating = false;\n\t},\n\n\t_getMatchingChild(children, url) {\n\t\tchildren = children.filter(prepareVNodeForRanking).sort(pathRankSort);\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tlet vnode = children[i];\n\t\t\tlet matches = exec(url, vnode.props.path, vnode.props);\n\t\t\tif (matches) return [vnode, matches];\n\t\t}\n\t},\n\n\trender({ children, onChange }, { url }) {\n\t\tlet ctx = this._contextValue;\n\n\t\tlet active = this._getMatchingChild(toChildArray(children), url);\n\t\tlet matches, current;\n\t\tif (active) {\n\t\t\tmatches = active[1];\n\t\t\tcurrent = cloneElement(\n\t\t\t\tactive[0],\n\t\t\t\tassign(assign({ url, matches }, matches), {\n\t\t\t\t\tkey: undefined,\n\t\t\t\t\tref: undefined\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\n\t\tif (url !== (ctx && ctx.url)) {\n\t\t\tlet newCtx = {\n\t\t\t\turl,\n\t\t\t\tprevious: ctx && ctx.url,\n\t\t\t\tcurrent,\n\t\t\t\tpath: current ? current.props.path : null,\n\t\t\t\tmatches\n\t\t\t};\n\n\t\t\t// only copy simple properties to the global context:\n\t\t\tassign(GLOBAL_ROUTE_CONTEXT, (ctx = this._contextValue = newCtx));\n\n\t\t\t// these are only available within the subtree of a Router:\n\t\t\tctx.router = this;\n\t\t\tctx.active = current ? [current] : [];\n\n\t\t\t// notify useRouter subscribers outside this subtree:\n\t\t\tfor (let i = SUBS.length; i--; ) SUBS[i]({});\n\n\t\t\tif (typeof onChange === 'function') {\n\t\t\t\tonChange(ctx);\n\t\t\t}\n\t\t}\n\n\t\treturn (\n\t\t\t<RouterContext.Provider value={ctx}>{current}</RouterContext.Provider>\n\t\t);\n\t}\n});\n\nconst Link = props => h('a', assign({ onClick: delegateLinkHandler }, props));\n\nconst Route = props => h(props.component, props);\n\nexport { getCurrentUrl, route, Router, Route, Link, exec, useRouter };\nexport default Router;\n"],
  "mappings": "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",
  "names": ["currentIndex", "currentComponent", "previousComponent", "prevRaf", "currentHook", "afterPaintEffects", "options", "_options", "oldBeforeDiff", "__b", "oldBeforeRender", "__r", "oldAfterDiff", "diffed", "oldCommit", "__c", "oldBeforeUnmount", "unmount", "oldRoot", "__", "getHookState", "index", "type", "__h", "hooks", "__H", "length", "push", "useState", "initialState", "useReducer", "invokeOrReturn", "reducer", "init", "hookState", "_reducer", "action", "currentValue", "__N", "nextValue", "setState", "__f", "updateHookState", "p", "s", "c", "stateHooks", "filter", "x", "every", "prevScu", "call", "this", "shouldUpdate", "props", "forEach", "hookItem", "shouldComponentUpdate", "prevCWU", "componentWillUpdate", "__e", "tmp", "useEffect", "callback", "args", "state", "__s", "argsChanged", "_pendingArgs", "useContext", "context", "provider", "currentComponent", "__c", "state", "getHookState", "currentIndex", "c", "__", "sub", "props", "value", "flushAfterPaintEffects", "component", "afterPaintEffects", "shift", "__P", "__H", "__h", "forEach", "invokeCleanup", "invokeEffect", "e", "options", "__e", "__v", "__b", "vnode", "currentComponent", "oldBeforeDiff", "__", "parentDom", "__k", "__m", "oldRoot", "__r", "oldBeforeRender", "currentIndex", "hooks", "__c", "previousComponent", "hookItem", "__N", "_pendingArgs", "diffed", "oldAfterDiff", "c", "length", "push", "prevRaf", "requestAnimationFrame", "afterNextFrame", "commitQueue", "some", "filter", "cb", "oldCommit", "unmount", "oldBeforeUnmount", "hasErrored", "s", "HAS_RAF", "callback", "raf", "done", "clearTimeout", "timeout", "cancelAnimationFrame", "setTimeout", "hook", "comp", "cleanup", "argsChanged", "oldArgs", "newArgs", "arg", "index", "invokeOrReturn", "f", "EMPTY", "assign", "obj", "props", "i", "exec", "url", "route", "opts", "ret", "reg", "c", "match", "matches", "p", "split", "length", "r", "decodeURIComponent", "slice", "join", "segmentize", "replace", "max", "Math", "charAt", "param", "flags", "plus", "indexOf", "star", "val", "map", "pathRankSort", "a", "b", "rank", "index", "prepareVNodeForRanking", "vnode", "path", "rankSegment", "segment", "ROUTERS", "SUBS", "customHistory", "GLOBAL_ROUTE_CONTEXT", "getCurrentUrl", "RouterContext", "createContext", "useRouter", "ctx", "useContext", "update", "useState", "useEffect", "push", "splice", "location", "getCurrentLocation", "pathname", "search", "canRoute", "type", "history", "routeTo", "didRoute", "routeFromLink", "node", "getAttribute", "href", "target", "prevent", "e", "stopImmediatePropagation", "stopPropagation", "preventDefault", "delegateLinkHandler", "ctrlKey", "metaKey", "altKey", "shiftKey", "button", "t", "localName", "hasAttribute", "parentNode", "eventListenersInitialized", "Router", "this", "state", "prototype", "Component", "shouldComponentUpdate", "onChange", "children", "toChildArray", "undefined", "_getMatchingChild", "setState", "_updating", "forceUpdate", "componentWillMount", "componentDidMount", "addEventListener", "_unlisten", "listen", "action", "_this", "componentWillUnmount", "componentWillUpdate", "componentDidUpdate", "filter", "sort", "render", "current", "_contextValue", "active", "cloneElement", "key", "ref", "previous", "router", "Provider", "value", "Link", "h", "onClick", "Route", "component"]
}
